= General Programming tasks =

This is a repository, where I store the tasks on my General Programming university course. 


== Task 1 ==

This task is dedicated to implementation of a Stack data structure in C programming language. The task is divided in several parts:

1. stack with capability to store only integer nubers;
2. stack with capability to store any type of data.

The both stacks have standard functionality to push (add an element), pop (delete an element), top (check the uppermost element), and create and desroy the stack.

The first part pf the task is completed in grindelf-stack-int header and source code files and simply stores integers as an array (a pointer to the integer value).

The second part is completed in grindelf-stack header and source code files and uses the 
[source, c]
----
void *
----
pointer to store the values of different types.

== Task 2 ==

The task is to create an implementation of a vector data structure in C programming language. Like the previous one the task is divided in several parts:

1. vector with capability to store only integer nubers;
2. vector with capability to store any type of data.

The both vectors have standard functionality to get data from the vector, to resize the vector, to append to the vector and to insert to the vector, as well as to create and to destroy the vector itself.

== Task 3 ==

=== Task 3.1 ===
Create a C++ template function dremove, which will be able to remove all occurances of arbitrary value from provided range [start, fin] of a container type, e.g. list or vector. It will have following signature:
[source, c++]
----
template<typename T, typename I>
I dremove(I start, I fin, T value);
----
where I are iterators' type and T is the container's values type.

The function should use iterators and should place one after the last element of the updated container with removed value instances.

=== Task 3.2 ===
 
Create a C++ template function dremoveIf, which will be able to remove all occurances of values from provided range [start, fin] of a container type which fit some given condition pred. It will have following signature:

[source, c++]
----
template<typename P, typename I>
I dremoveIf(I start, I fin, P pred);
----
where I are iterators' type and P is the type of predicate condition.

The function should use iterators and should place one after the last element of the updated container with removed value instances.

=== Task 3.3 ===
 
Create a C++ template function transform, which will be able to apply some function of type F to each value from provided range [start, fin]. It will have following signature:

[source, c++]
----
template<typename I, typename F>
I transform(I start, I fin, F fucnt);
----
where I are iterators' type and F is the type of the function. The function operates with values of type T which is not provided as a template.

The function should use iterators and should place one after the last element of the new container.

=== Task 3.4 ===
 
Create a C++ template function dunique, which will return a new collection containing only unique values out of old collection from provided range [start, fin]. It will have following signature:

[source, c++]
----
template<typename I>
I dunique(I start, I fin);
----
where I are iterators' type.

The function should use iterators and should place one after the last element of the new container.

== Task 4 ==

With a given set of segments (eg [1, 2], [7, 2]) make set of broken lines formed by this segments (in the case of this example it will be [1, 2, 7]). The segments can lead to cyucled broken lines but broken lines may not have branches.

